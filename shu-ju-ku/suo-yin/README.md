# 索引

索引相当于一本一千页的书的目录，可以提高数据查询的效率。

## 常见模型

常见的用于实现索引的数据结构有哈希表、有序数组和B+树，这些数据结构有各自适应的场合。

* 哈希表：存储`(key, value)`对，通过哈希函数得到每个key在数组中的下标，如果出现哈希冲突，则用链表法解决。哈希表可以快速找到数据的位置，但是不利于区间查询，因此**哈希表适用于只有等值查询的场景**，比如Memcached及其他一些NoSQL引擎。
* 有序数组：**在等值查询和范围查询场景中的性能就都非常优秀**。查询值时，通过二分查找，时间复杂度为`O(log n)`。但是更新数据时比较麻烦，比如往中间插入一个记录就必须得挪动后面所有的记录，成本太高。

  所以，**有序数组索引只适用于静态存储引擎**，比如要保存的是2017年某个城市的所有人口信息，这类不会再修改的数据。

### 树

以二叉搜索树为例，每个节点的左儿子小于父节点，父节点又小于右儿子。在查找值的时候，时间复杂度为`O(log n)`。为了维持这个时间复杂度，需要使用**平衡二叉搜索树**，更新的时间复杂度也是`O(log n)`。

但是二叉树对于数据库这种需要经常与磁盘IO的应用来说并不是最佳选择，因为索引存储在磁盘上，从磁盘读入内存的时候，由于树只有二叉，导致树很高，对应的，需要访问的数据块个数（即磁盘IO的次数）就很多。

> 例如一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要10 ms左右的寻址时间。也就是说，对于一个100万行的表，如果使用二叉树来存储，单独访问一个行可能需要20个10 ms的时间，这个查询可真够慢的。

为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。因此需要使用“N叉”树。这里，“N叉”树中的“N”取决于数据块的大小，理想情况下，N个数据块大小刚好等于1页的大小。

以InnoDB的一个整数字段索引为例，这个N差不多是1200。这棵树高是4的时候，就可以存1200的3次方个值，这已经17亿了。考虑到树根的数据块总是在内存中的，一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。

N叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。

## InooDB的索引模型

在MySQL中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。

InnoDB存储引擎在MySQL数据库中使用最为广泛，**在InnoDB中，表都是根据主键顺序以索引的形式存放的**，这种存储方式的表称为**索引组织表**。又因为InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。

每一个索引在InnoDB里面对应一棵B+树。

假设有一个主键列为ID的表，表中有字段k，并且在k上有索引。

```text
mysql> create table T(
id int primary key, 
k int not null, 
name varchar(16),
index (k))engine=InnoDB;
```

表中R1~R5的`(ID,k)`值分别为`(100,1)、(200,2)、(300,3)、(500,5)和(600,6)`，两棵索引树如图：

![1586928956514](https://github.com/wsfy15/gitbook/tree/6f2306b59c065eb5bc72e6f4f1040665a793199a/.gitbook/assets/1586928956514.png)

根据叶子节点的内容，索引类型分为**主键索引**和**非主键索引**。

* 主键索引的叶子节点存的是**整行数据**。在InnoDB里，主键索引也被称为**聚簇索引**（clustered index）。
* 非主键索引的叶子节点内容是**主键的值**。在InnoDB里，非主键索引也被称为**二级索引**（secondary index）。

因此，基于主键索引的查询可以直接得到对应的行，而普通索引查询需要先查询索引树得到主键，再到主键的索引树搜索。

* `select * from T where ID=500`，即主键查询方式，只需要搜索ID这棵B+树
* `select * from T where k=5`，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为**回表**。

基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。

### 索引维护

B+树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面的索引为例，如果插入新的行ID值为700，则只需要在R5的记录后面插入一个新记录。如果新插入的ID值为400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。

而更糟的情况是，如果R5所在的数据页已经满了，根据B+树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为**页分裂**。在这种情况下，性能自然会受影响。

除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约50%。

当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。

#### 自增主键

在一些建表规范里面有这样的描述，要求建表语句里一定要有**自增主键**。

> 自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的：`NOT NULL PRIMARY KEY AUTO_INCREMENT`。

插入新记录的时候可以不指定ID的值，系统会获取当前ID最大值加1作为下一条记录的ID值。

自增主键的插入数据模式，是递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也**不会触发叶子节点的分裂**。

而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。

除了考虑性能外，还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？

由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约20个字节，而如果用整型做主键，则只要4个字节，如果是长整型（bigint）则是8个字节。

**显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。**

所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。

适合**用业务字段直接做主键**的场景有哪些呢？

* 只有一个索引
* 该索引必须是唯一索引

这就是典型的KV场景。由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。

### 重建索引

索引可能因为删除，或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。

对于表`T`的主键索引和普通索引，在删除索引的时候会发生什么？

```text
// 重建普通索引
mysql> alter table T drop index k;
mysql> alter table T add index(k);

// 重建主键索引
mysql> alter table T drop primary key;
mysql> alter table T add primary key(id);
```

重建普通索引的做法是合理的，可以达到省空间的目的。

但是，**重建主键的过程不合理**。不论是删除主键还是创建主键，都会将整个表重建。可以用`alter table T engine=InnoDB`语句替代，这个语句会重建整个表,删掉未使用的空白空间。

## 覆盖索引

```text
mysql> create table T (
    ID int primary key,
    k int NOT NULL DEFAULT 0, 
    s varchar(16) NOT NULL DEFAULT '',
    index k(k)) engine=InnoDB;

insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg');
```

对于上面的表`T`，执行查询语句`select * from T where k between 3 and 5`时，需要执行几次树的搜索操作，会扫描多少行？

![&#x7D22;&#x5F15;&#x7EC4;&#x7EC7;&#x7ED3;&#x6784;](https://github.com/wsfy15/gitbook/tree/6f2306b59c065eb5bc72e6f4f1040665a793199a/.gitbook/assets/1586955472642.png)

这条查询语句的执行流程：

1. 在k索引树上找到`k=3`的记录，取得 `ID = 300`；
2. 再到ID索引树查到`ID=300`对应的R3；
3. 在k索引树取下一个值`k=5`，取得`ID=500`；
4. 再回到ID索引树查到`ID=500`对应的R4；
5. 在k索引树取下一个值`k=6`，不满足条件，循环结束。

在这个过程中，**回到主键索引树搜索的过程，我们称为回表**。可以看到，这个查询过程读了k索引树的3条记录（步骤1、3和5），回表了两次（步骤2和4）。

由于查询结果所需要的数据只在主键索引上有，所以不得不回表。

如果执行的查询语句是`select ID from T where k between 3 and 5`，即只需要`ID`的值，而`ID`的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询需求，这就是**覆盖索引**。

**由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。**

> 在引擎内部使用覆盖索引在索引k上其实**读了三个记录**，R3~R5（对应的索引k上的记录项），但是对于MySQL的Server层来说，它就是找引擎拿到了两条记录，因此MySQL认为**扫描行数是2**。

### 最左前缀原则

```text
mysql> CREATE TABLE `tuser` (
  `id` int(11) NOT NULL,
  `id_card` varchar(32) DEFAULT NULL,
  `name` varchar(32) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  `ismale` tinyint(1) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `id_card` (`id_card`),
  KEY `name_age` (`name`,`age`)
) ENGINE=InnoDB
```

上面创建了一个市民信息表，身份证号是市民的唯一标识，如果有根据身份证号查询市民信息的需求，我们只要在身份证号字段上建立索引就够了。但是这种查询是需要回表的。

如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，那么建立一个`(身份证号、姓名)`的联合索引就有意义了。它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。

当然，索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。

如果为每一种查询都设计一个索引，索引是不是太多了。如果我现在要按照市民的身份证号去查他的家庭地址呢？这个查询需求在业务中出现的概率不高，单独为一个不频繁的请求创建一个（身份证号，地址）的索引又感觉有点浪费。应该怎么做呢？

**B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录。**以`(name，age)`这个联合索引来分析。

![&#xFF08;name&#xFF0C;age&#xFF09;&#x7D22;&#x5F15;&#x793A;&#x610F;&#x56FE;](https://github.com/wsfy15/gitbook/tree/6f2306b59c065eb5bc72e6f4f1040665a793199a/.gitbook/assets/1586956785863.png)

索引项是按照索引定义里面出现的字段顺序排序的。

当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到ID4，然后向后遍历得到所有需要的结果。

如果你要查的是所有名字第一个字是“张”的人，SQL语句的条件是`where name like ‘张%’`。这时，你也能够用上这个索引，查找到第一个符合条件的记录是ID3，然后向后遍历，直到不满足条件为止。

**不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。**

因此，**在建立联合索引的时候，需要合理安排索引内的字段顺序。**这里的指标是索引的复用能力。

因为可以支持最左前缀，所以当已经有了`(a,b)`这个联合索引后，一般就不需要单独在`a`上建立索引了。

因此，**第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。**

因此，为高频请求创建`(身份证号，姓名）`这个联合索引，这个索引同时也支持“根据身份证号查询地址”的需求（只需要回表，而不用全表扫描）。

如果既有联合查询，又有基于a、b各自的查询呢？查询条件里面只有b的语句，是无法使用`(a,b)`这个联合索引的，这时候不得不维护另外一个索引，也就是说你需要同时维护`(a,b)、(b)`这两个索引。

这时候，我们要**考虑的原则就是空间**了。比如上面这个市民表的情况，由于`name`字段是比`age`字段大的 ，所以优先考虑创建一个`（name,age)`的联合索引和一个`(age)`的单字段索引。

## 索引下推

最左前缀可以用于在索引中定位记录，那些不符合最左前缀的部分，又该如何处理呢？

以市民表的联合索引`（name, age）`为例。如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是10岁的所有男孩”，SQL语句如下：

```text
mysql> select * from tuser where name like '张%' and age=10 and ismale=1;
```

这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录ID3。接下来要判断其他条件是否满足。

* 在MySQL 5.6之前，只能从ID3开始一个个回表。到主键索引上找出数据行，再对比字段值。

  ![&#x65E0;&#x7D22;&#x5F15;&#x4E0B;&#x63A8;&#x6267;&#x884C;&#x6D41;&#x7A0B;](https://github.com/wsfy15/gitbook/tree/6f2306b59c065eb5bc72e6f4f1040665a793199a/.gitbook/assets/1586957981531.png)

  在`(name,age)`索引里特意去掉了age的值，因为这个过程InnoDB并不会去看age的值，只是按顺序把“name第一个字是’张’”的记录一条条取出来回表。因此，需要回表4次。

* MySQL 5.6 引入了**索引下推优化**（index condition pushdown\)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

  ![&#x7D22;&#x5F15;&#x4E0B;&#x63A8;&#x6267;&#x884C;&#x6D41;&#x7A0B;](https://github.com/wsfy15/gitbook/tree/6f2306b59c065eb5bc72e6f4f1040665a793199a/.gitbook/assets/1586957996888.png)

  InnoDB在`(name,age)`索引内部就判断了age是否等于10，对于不等于10的记录，直接判断并跳过。在这个例子中，只需要对ID4、ID5这两条记录回表取数据判断，就只需要回表2次。

## 多余的索引

```text
CREATE TABLE `geek` (
  `a` int(11) NOT NULL,
  `b` int(11) NOT NULL,
  `c` int(11) NOT NULL,
  `d` int(11) NOT NULL,
  PRIMARY KEY (`a`,`b`),
  KEY `c` (`c`),
  KEY `ca` (`c`,`a`),
  KEY `cb` (`c`,`b`)
) ENGINE=InnoDB;
```

上面的建表语句中，主键包含了a、b这两个字段，那意味着单独在字段c上创建一个索引，就已经包含了三个字段了呀，又创建“ca”“cb”这两个索引是为了支持下面的查询语句。

```text
mysql> select * from geek where c=N order by a limit 1;
mysql> select * from geek where c=N order by b limit 1;
```

这么做并不合理，会导致其中一个索引多余。

假设表记录如下：

```text
表记录
–a--|–b--|–c--|–d--
1 2 3 d
1 3 2 d
1 4 3 d
2 1 3 d
2 2 2 d
2 3 4 d
```

主键 a，b的聚簇索引组织顺序相当于 `order by a, b` ，也就是先按a排序，再按b排序，c无序。

索引`ca`的组织是先按c排序，再按a排序，同时记录主键。**这个跟索引c的数据是一模一样的。**

```text
–c--|–a--|–主键部分b-- 
2 1 3
2 2 2
3 1 2
3 1 4
3 2 1
4 2 3
```

索引 `cb` 的组织是先按c排序，在按b排序，同时记录主键。

```text
–c--|–b--|–主键部分a--
2 2 2
2 3 1
3 1 2
3 2 1
3 4 1
4 3 2
```

所以，`ca`是多余的索引，可以去掉，`cb`需要保留。

## 思考题

```text
mysql> UPDATE t SET in_time = '2018-08-04 08:34:44' WHERE 1=2 or CODE = 1;
```

对于表`t`，即使在`CODE`字段上有索引，这条语句也不会走这个索引。

因为`WHERE`条件是`or`，如果改成`and`的话就会走索引，因为满足条件的数据行是满足`CODE`字段要求的数据的子集，可以先选出满足`CODE=1`的数据行后再做前面的判断。而`or`的话，满足条件的数据行不只满足`CODE=1`的数据，因此不走索引。

