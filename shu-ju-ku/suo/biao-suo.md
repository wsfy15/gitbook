# 表锁

MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL\)。

## 表锁

**表锁的语法是 `lock tables … read/write`。**与FTWRL类似，可以用`unlock tables`主动释放锁，也可以在客户端断开的时候自动释放。需要注意，**`lock tables`语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。**

如果在某个线程A中执行`lock tables t1 read, t2 write;`这个语句，则其他线程写`t1`、读写`t2`的语句都会被阻塞。同时，线程A在执行`unlock tables`之前，也只能执行读`t1`、读写`t2`的操作。连写`t1`都不允许，自然也不能访问其他表。

在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于InnoDB这种支持行锁的引擎，一般不使用`lock tables`命令来控制并发，毕竟锁住整个表的影响面还是太大。

表锁一般是在数据库引擎不支持行锁的时候才会被用到的。如果你发现你的应用程序里有`lock tables`这样的语句，比较可能的情况是：

* 要么是你的系统现在还在用MyISAM这类不支持事务的引擎，那要安排升级换引擎；
* 要么是你的引擎升级了，但是代码还没升级，需要把`lock tables` 和 `unlock tables` 改成 `begin`和 `commit`。

## 元数据锁

MDL不需要显式使用，**在访问一个表的时候会被自动加上。**MDL的作用是，保证读写的正确性。

如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。

因此，在MySQL 5.5版本中引入了MDL，**当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。**

* 读锁之间不互斥，因此可以有多个线程同时对一张表增删改查。
* 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

虽然MDL锁是系统默认会加的，但却是不能忽略的一个机制。比如下面这个例子，给一个小表加个字段，导致整个库挂了。

> 给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。在对大表操作的时候，要特别小心，以免对线上服务造成影响。而实际上，即使是小表，操作不慎也会出问题。

![1586962987138](../../.gitbook/assets/1586962987138.png)

session A先启动，这时候会对表t加一个MDL读锁。由于session B需要的也是MDL读锁，因此可以正常执行。

之后session C会被blocked，是因为session A的MDL读锁还没有释放，而session C需要MDL写锁，因此只能被阻塞。

如果只有session C自己被阻塞还没什么关系，但是之后所有要在表t上新申请MDL读锁的请求也会被session C阻塞。所有对表的增删改查操作都需要先申请MDL读锁，就都被锁住，等于这个表现在完全不可读写了。

如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新session再请求的话，这个库的线程很快就会爆满。

事务中的MDL锁，在语句执行开始时申请，但是**语句结束后并不会马上释放，而是会等到整个事务提交后再释放。**

### 安全地操作表的字段

首先要解决长事务，事务不提交，就会一直占着MDL锁。在MySQL的`information_schema.innodb_trx`表中，可以查到当前执行中的事务。如果要做DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务。

如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，该怎么做呢？

这时候kill可能未必管用，因为新的请求马上就来了。比较理想的机制是，**在`alter table`语句里面设定等待时间**，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者DBA再通过重试命令重复这个过程。

MariaDB已经合并了AliSQL的这个功能，所以这两个开源数据库目前都支持`DDL NOWAIT/WAIT n`这个语法。

```text
mysql> ALTER TABLE tbl_name NOWAIT add column ...
mysql> ALTER TABLE tbl_name WAIT N add column ...
```

