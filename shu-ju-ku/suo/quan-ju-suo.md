# 全局锁

全局锁就是**对整个数据库实例加锁**。MySQL提供了一个加全局读锁的方法，命令是 `Flush tables with read lock`\(FTWRL\)。当你需要**让整个库处于只读状态**的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。

## 备份

**全局锁的典型使用场景是，做全库逻辑备份。**也就是把整库每个表都`select`出来存成文本。

通过FTWRL可以确保不会有其他线程对数据库做更新，然后对整个库做备份。**在备份过程中整个库完全处于只读状态**：

* 如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；
* 如果在从库上备份，那么备份期间从库不能执行主库同步过来的`binlog`，会导致主从延迟。

如果备份不加锁，会导致什么问题呢？

假设现在要维护“极客时间”的购买系统，关注的是用户账户余额表和用户课程表。

现在发起一个逻辑备份。假设备份期间，有一个用户，他购买了一门课程，业务逻辑里就要扣掉他的余额，然后往已购课程里面加上一门课。

如果时间顺序上是先备份账户余额表\(`u_account`\)，然后用户购买，然后备份用户课程表\(`u_course`\)，会怎么样呢？

![&#x4E1A;&#x52A1;&#x548C;&#x5907;&#x4EFD;&#x72B6;&#x6001;&#x56FE;](../../.gitbook/assets/1586961593569.png)

可以看到，这个备份结果里，用户A的数据状态是“账户余额没扣，但是用户课程表里面已经多了一门课”。

**不加锁的话，备份系统备份得到的库不是一个逻辑时间点，这个视图是逻辑不一致的。**

既然提到了视图，那么在**可重复读**隔离级别下开启一个事务进行备份，不就可以保证在这个一致性视图里得到的数据是事务启动时的状态。

> 官方自带的逻辑备份工具是`mysqldump`。当`mysqldump`使用参数`–single-transaction`的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。**而由于MVCC的支持，这个过程中数据是可以正常更新的。**

之所以有了可重复读隔离级别的支持，还有FTWRL的存在，是因为**事务隔离级别的支持是存储引擎层提供的**，而对于MyISAM这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。

所以，**single-transaction方法只适用于所有的表使用事务引擎的库。**如果有的表使用了不支持事务的引擎，那么备份就只能通过FTWRL方法。

**要保证全库只读，还可以使用`set global readonly=true`。**虽然`readonly`方式也可以让全库进入只读状态，但还是建议使用FTWRL方式，主要有两个原因：

* 在有些系统中，`readonly`的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改global变量的方式影响面更大，不建议使用。
* 在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。

  而将整个库设置为`readonly`之后，如果客户端发生异常，则数据库就会一直保持`readonly`状态，这样会导致整个库长时间处于不可写状态，风险较高。

业务的更新不只是增删改数据（DML\)，还有可能是加字段等修改表结构的操作（DDL）。不论是哪种方法，一个库被全局锁上以后，要对里面任何一个表做加字段操作，都是会被锁住的。

### 备份时执行DDL

备份一般都会在备库上执行，在用`–single-transaction`方法做逻辑备份的过程中，如果主库上的一个小表做了一个DDL，比如给一个表上加了一列。这时候，从备库上会看到什么现象呢？

假设这个DDL是针对表`t1`的， 备份过程中几个关键的语句如下：

```text
Q1:SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
Q2:START TRANSACTION  WITH CONSISTENT SNAPSHOT；
/* other tables */
Q3:SAVEPOINT sp;
/* 时刻 1 */
Q4:show create table `t1`;
/* 时刻 2 */
Q5:SELECT * FROM `t1`;
/* 时刻 3 */
Q6:ROLLBACK TO SAVEPOINT sp;
/* 时刻 4 */
/* other tables */
```

* Q1：在备份开始的时候，为了确保RR（可重复读）隔离级别，再设置一次RR隔离级别
* Q2：启动事务，这里用 `WITH CONSISTENT SNAPSHOT`确保这个语句执行完就可以得到一个一致性视图
* Q3：设置一个保存点，这个很重要，后续可以回滚到该保存点，以释放表`t1`的MDL锁
* Q4：show create 是为了拿到表结构
* Q4：`show create` 是为了拿到表结构
* Q5：正式导数据 
* Q6：回滚到`SAVEPOINT sp`，在这里的作用是释放 `t1`的MDL锁 

DDL从主库传过来的时间按照效果不同，我打了四个时刻。题目设定为小表，因此假定到达后，如果开始执行，则很快能够执行完成。

1. 如果在Q4语句执行之前到达，现象：没有影响，备份拿到的是DDL后的表结构。
2. 如果在“时刻 2”到达，则表结构被改过，Q5执行的时候，报 `Table definition has changed, please retry transaction`，现象：mysqldump终止；
3. 如果在“时刻2”和“时刻3”之间到达，mysqldump占着`t1`的MDL读锁，binlog被阻塞，现象：主从延迟，直到Q6执行完成。
4. 从“时刻4”开始，mysqldump释放了MDL读锁，现象：没有影响，备份拿到的是DDL前的表结构。

