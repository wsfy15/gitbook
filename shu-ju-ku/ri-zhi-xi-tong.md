# 日志系统

通过更新语句的执行过程介绍日志系统。首先创建表`T`：

```
mysql> create table T(ID int primary key, c int);
```

执行更新语句`update T set c=c+1 where ID=1;`时，根据语句的执行流程，在连接数据库后，会将与表`T`相关的所有查询缓存失效，然后通过词法分析和语法分析知道这是一条合法的更新语句，优化器决定使用`ID`索引，由执行器负责具体执行，找到该行并更新。

与查询流程不同的是，更新流程还涉及`redo log`（重做日志）和 `binlog`（归档日志）。

## redo log

当执行更新语句时，如果要同时写入磁盘，那么磁盘需要找到对应的记录，然后更新，对于单个更新操作，这个过程IO成本、查找成本比较高，降低了MySQL的运行效率。

因此，可以先将更新语句写入日志（追加方式比较快，且不需要打开日志文件的开销，日志文件句柄应该已经由某些线程控制了），（不忙的时候）再写磁盘，即**WAL技术**（Write-Ahead Logging）。

> 可能有一个线程负责日志IO，当执行语句的线程执行到更新处时，只需要往全局的日志接口添加该更新的日志，负责日志的线程定时读取内存中的批量日志，追加方式写入redo log，这样效率比较高，不会阻塞执行线程。
>
> 不过，对于redo log，应该是每有一个更新操作，就会写入磁盘上的日志文件，这样才能保证所有执行过的操作都被记录。

具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到`redo log`里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。

不过，`redo log`的大小是有限制的，例如，可以配置为一组4个文件，每个文件大小为1GB，那么最多可以记录4GB的操作。写的方式是**从头开始写，写到末尾就又回到开头循环写**。

![1586837656782](ri-zhi-xi-tong.assets/1586837656782.png)

- `write pos`是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。
- `checkpoint`是还未写入磁盘的操作的起点，也是往后推移并且循环的，后移时需要将该记录更新到磁盘。

`write pos`和`checkpoint`之间的空间可以用来记录新的操作，如果`write po`追上了 `checkpoint`，即当MySQL负载一直很高时，没空后移`checkpoint`，导致`redo log`写满了，那么这时就只能先停止对外的服务，先将`redo log`中的一部分更新到磁盘上，推进`checkpoint`，为接下来的更新腾出空间。

有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为**crash-safe**。

`innodb_flush_log_at_trx_commit`这个参数设置成1的时候，表示每次事务的`redo log`都直接持久化到磁盘，设置成1可以保证MySQL异常重启之后数据不丢失。

## binlog

MySQL整体来看，由Server层和存储引擎层组成。上面介绍的的`redo log`是InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog。

> 之所以会有两份日志，是因为最开始MySQL没用InnoDB引擎，MySQL自带的引擎是MyISAM，而MyISAM没有crash-safe的能力，binlog日志也只能用于归档。
>
> InnoDB是另一个公司以插件形式引入MySQL的，以实现crash-safe能力，即通过redo log实现。

`sync_binlog`这个参数设置成1的时候，表示每次事务的`binlog`都持久化到磁盘，设置成1可以保证MySQL异常重启之后`binlog`不丢失。

### 与redo log的区别

- `redo log`是InnoDB引擎特有的；
- `binlog`是MySQL的Server层实现的，所有引擎都可以使用。
- `redo log`是物理日志，记录的是“在某个数据页上做了什么修改”
- `binlog`是逻辑日志，记录的是这个语句的原始逻辑，比如“给`ID=2`这一行的c字段加1 ”
- `redo log`是循环写的，空间固定会用完
- `binlog`是可以追加写入的。“追加写”是指`binlog`文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。



在执行更新语句`update T set c=c+1 where ID=1;`时，流程如下：

1. 执行器先找引擎取`ID=1`这一行。ID是主键，引擎直接用树搜索找到这一行。如果`ID=1`这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
2. 执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到`redo log`里面，此时`redo log`处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。
4. 执行器生成这个操作的`binlog`，并把`binlog`写入磁盘。
5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的`redo log`改成提交（commit）状态，更新完成。

![1586843121296](ri-zhi-xi-tong.assets/1586843121296.png)

图中浅色框表示是在InnoDB内部执行的，深色框表示是在执行器中执行的。

最后三步将`redo log`的写入拆成了两个步骤：prepare和commit，这就是"两阶段提交"。

## 两阶段提交

为什么要采用两阶段提交？

对数据库备份和恢复是通过`binlog`实现的，`binlog`会记录所有的逻辑操作，并且是采用“追加写”的形式。备份系统中会保存最近的`binlog`，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。

当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：

- 首先，找到最近的一次全量备份，如果运气好，可能就是昨天晚上的一个备份，从这个备份恢复到**临时库**
- 然后，从备份的时间点开始，将备份的`binlog`依次取出来，重放到中午误删表之前的那个时刻

这样临时库就跟误删之前的线上库一样了，然后就可以把表数据从临时库取出来，按需要恢复到线上库去。

如果日志不采用两阶段提交，由于`redo log`和`binlog`是两个独立的逻辑，一个是Server层，一个是存储引擎层。考虑先写`redo log`再写`binlog`，或者相反的顺序，假设当前有一条更新语句，将`ID=1`的行的字段`c`加一（0->1），如果写完第一个日志后，第二个日志还没写完就发生了crash，这两种顺序的写法会产生什么后果呢？

- **先写redo log后写binlog**。假设在`redo log`写完，`binlog`还没有写完的时候，MySQL进程异常重启。由于`redo log`提供了crash-safe的能力，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行`c`的值是1。
  但是由于`binlog`没写完就crash了，这时候`binlog`里面就没有记录这个语句。因此，之后备份日志的时候，存起来的`binlog`里面就没有这条语句。
  然后你会发现，如果需要用这个`binlog`来恢复临时库的话，由于备份恢复只与`binlog`相关，而这个语句的`binlog`丢失，这个临时库就会少了这一次更新，恢复出来的这一行`c`的值就是0，与原库的值不同。
- **先写binlog后写redo log**。如果在`binlog`写完之后crash，由于`redo log`还没写，而崩溃恢复读的是`redo log`，而不是`binlog`，导致崩溃恢复后这个事务无效，所以这一行`c`的值是0。但是`binlog`里面已经记录了“把c从0改成1”这个日志。所以，在之后用`binlog`来恢复的时候就多了一个事务出来，恢复出来的这一行`c`的值就是1，与原库的值不同。

因此，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。



##  备份周期的选择

一天一备与一周一备的对比：

- 在一天一备的模式里，最坏情况下只需要应用一天的`binlog`。
- 一周一备最坏情况就要应用一周的`binlog`了。

对应的系统指标是RTO（恢复目标时间）。

不过，更频繁全量备份需要消耗更多存储空间，所以这个RTO是成本换来的，需要根据业务重要性来评估了。

