# Bmore树

## 数据库索引

B+树常用于数据库中的索引，常见的使用索引的方式有：

* 根据某个值查找数据，比如`select * from user where id=1234`
* 根据区间值来查找某些数据，比如`select * from user where id > 1234 and id < 2345`

对于索引，希望在执行效率方面，通过索引查询数据的效率尽可能的高；在存储空间方面，索引不要消耗太多的内存空间。

**使用什么数据结构实现索引？**

* **散列表**：查询性能好\($O\(1\)$\)，但不支持按照区间快速查找数据
* **平衡二叉树**：查询的性能也很高\($O\(logn\)$\)；对树进行中序遍历，可以得到一个从小到大有序的数据序列，但这仍然不足以支持按照区间**快速**查找数据
* **跳表**：跳表就是在链表之上加上多层索引构成的。它支持快速地插入、查找、删除数据，对应的时间复杂度是$O\(logn\)$。并且，跳表也支持按照区间快速地查找数据。我们只需要定位到区间起点值对应在链表中的结点，然后从这个结点开始，顺序遍历链表，直到区间终点对应的结点为止，这期间遍历得到的数据就是满足区间值的数据。

  ![1583675961208](../../.gitbook/assets/1583675961208.png)

跳表是可以解决这个问题。实际上，数据库索引所用到的数据结构跟跳表非常相似，叫作B+树。不过，它是通过二叉搜索树演化过来的，而非跳表。

## 改造二叉搜索树实现索引

为了让二叉查找树支持按照区间来查找数据，我们可以对它进行这样的改造：**树中的节点并不存储数据本身，而是只是作为索引。**除此之外，我们**把每个叶子节点串在一条链表上，链表中的数据是从小到大有序的**。

![1583676164448](../../.gitbook/assets/1583676164448.png)

改造之后，如果我们要求某个区间的数据。我们只需要拿区间的起始值，在树中进行查找，当查找到某个叶子节点之后，我们再顺着链表往后遍历，直到链表中的结点数据值大于区间的终止值为止。所有遍历到的数据，就是符合区间值的所有数据。

![1583676198832](../../.gitbook/assets/1583676198832.png)

### 内存优化：二叉-&gt;m叉

但是，我们要为几千万、上亿的数据构建索引，如果将索引存储在内存中，尽管内存访问的速度非常快，查询的效率非常高，但是，占用的内存会非常多。

比如，我们给一亿个数据构建二叉查找树索引，那索引中会包含大约1亿个节点，每个节点假设占用16个字节，那就需要大约2GB的内存空间。给一张表建立索引，我们需要2GB的内存空间。如果我们要给10张表建立索引，那对内存的需求是无法满足的。

借助**时间换空间**的思路，把索引存储在硬盘中，而非内存中。

虽然减少了内存消耗，但是在数据查找的过程中，需要读取磁盘中的索引（通过减少磁盘IO的次数进一步优化），因此数据查询效率就相应降低很多。

二叉查找树，经过改造之后，支持区间查找的功能就实现了。不过，为了节省内存，如果把树存储在硬盘中，那么每个节点的读取（或者访问），都对应一次磁盘IO操作。树的高度就等于每次查询数据时磁盘IO操作的次数。

比起内存读写操作，磁盘IO操作非常耗时，所以我们优化的重点就是尽量减少磁盘IO操作，也就是，尽**量降低树的高度**。

给16个数据构建二叉树索引，树的高度是4，查找一个数据，就需要4个磁盘IO操作（如果根节点存储在内存中，其他结点存储在磁盘中）。

![1583676455871](../../.gitbook/assets/1583676455871.png)

如果对16个数据构建五叉树索引，那高度只有2，查找一个数据，对应只需要2次磁盘操作。

![1583676497496](../../.gitbook/assets/1583676497496.png)

如果m叉树中的m是100，那对一亿个数据构建索引，树的高度也只是4，最多只要4次磁盘IO就能获取到数据。磁盘IO变少了，查找数据的效率也就提高了。

因此可以通过m叉树的方式减少磁盘IO次数，而m的取值的确定很有技巧。

### m的取值

对于相同个数的数据构建`m`叉树索引，`m`叉树中的`m`越大，那树的高度就越小。不过，`m`叉树中的`m`并不是越大越好。

不管是内存中的数据，还是磁盘中的数据，操作系统都是按页（一页大小通常是4KB，这个值可以通过`getconfig PAGE_SIZE`命令查看）来读取的，一次会读一页的数据。如果要读取的数据量超过一页的大小，就会触发多次IO操作。所以，我们在选择`m`大小的时候，要**尽量让每个节点的大小等于一个页的大小**。读取一个节点，只需要一次磁盘IO操作。

假设给int类型的数据库字段\(所以代码中的keywords是int类型的\)添加索引，则树节点定义如下

```text
// B+树非叶子节点
// 假设keywords=[3, 5, 8, 10]
// 4个键值将数据分为5个区间：(-INF,3), [3,5), [5,8), [8,10), [10,INF) 
// 5个区间对应5个children
// 尽量满足 PAGE_SIZE = 4 + (m-1) * 4 + m * 8 (int大小为4字节，指针大小8字节)
type BPlusTreeNode struct {
    m int
    keywords [m-1]int
    children [m]*BPlusTreeNode
}

// B+树叶子节点 存储的是值，不是区间，每个叶子节点存储k个数据行的键值和地址
// 尽量满足 PAGE_SIZE = 4 + k * 4 + k * 8 + 2 * 8 (int大小为4字节，指针大小8字节)
type BPlusTreeLeafNode struct {
    k int
    keywords [k]int32
    dataAddress [k]int64
    prev *BPlusTreeLeafNode // 这个结点在链表中的前驱结点
    next *BPlusTreeLeafNode // 这个结点在链表中的后继结点
}
```

> 叶子节点的链表是双向链表，这样才可以方便地支持查询中的`desc`和`asc`。存储两个指针，相比单链表多了一个，但因为这些节点是存储在硬盘中的，所以这点空间不要太计较。

上面的定义是为了凸显两种节点的功能，实际上，两种节点的类型都是一样的，否则倒数第二层的中间节点的children无法指向叶子节点。因此也会浪费一些空间。

```text
type BPlusTreeNode struct {
    isLeaf bool // 是否是叶子节点
    isRoot bool // 是否是根节点
    parent, prev, next BPlusTreeNode

    keywords []int
    children []*BPlusTreeNode
}
```

这样子定义又好像不能使每个节点大小尽量等于页的大小了。

![1583676817141](../../.gitbook/assets/1583676817141.png)

### 动态更新

尽管索引可以提高数据库的查询效率，但它也会让 写入/删除 数据的效率下降。

#### 写入

数据的写入过程，会涉及索引的更新，这是索引导致写入变慢的主要原因。

对于一个B+树来说，m值是根据页的大小事先计算好的，也就是说，每个节点最多只能有m个子节点。在往数据库中写入数据的过程中，这样就有可能使索引中某些节点的子节点个数超过m，这个节点的大小超过了一个页的大小，读取这样一个节点，就会导致多次磁盘IO操作。

遇到这种情况时，我们只需要将这个节点分裂成两个节点。但是，节点分裂之后，其上层父节点的子节点个数就有可能超过m个。不过这也没关系，我们可以用同样的方法，将父节点也分裂成两个节点。这种级联反应会从下往上，一直影响到根节点。

下图中的B+树是一个三叉树。我们限定**叶子节点中，数据的个数超过2个就分裂节点；非叶子节点中，子节点的个数超过3个就分裂节点。**

![img](../../.gitbook/assets/1800bc80e1e05b32a042ff6873e6c2e0.jpg)

#### 删除

在删除某个数据的时候，也要对应的更新索引节点。这个处理思路有点类似跳表中删除数据的处理思路。频繁的数据删除，就会导致某些结点中，子节点的个数变得非常少，长此以往，如果每个节点的子节点都比较少，势必会影响索引的效率。

我们可以设置一个阈值。在B+树中，这个阈值等于`m/2`。如果某个节点的子节点个数小于`m/2`，我们就将它跟相邻的兄弟节点合并。不过，合并之后结点的子节点个数有可能会超过m。针对这种情况，我们可以借助插入数据时候的处理方法，再分裂节点。

下图中的B+树是一个五叉树。我们限定叶子节点中，数据的个数少于2个就合并节点；非叶子节点中，子节点的个数少于3个就合并节点。

![img](../../.gitbook/assets/1730e34450dad29f062e76536622c918.jpg)

## 总结

B+树通过存储在磁盘的多叉树结构，做到了时间、空间的平衡，既保证了执行效率，又节省了内存。它具有如下特点：

* 每个节点中子节点的个数不能超过`m`，也不能小于`m/2`
* 根节点的子节点个数可以不超过`m/2`，这是一个例外
* `m`叉树只存储索引，并不真正存储数据，这个有点儿类似跳表
* 通过链表将叶子节点串联在一起，这样可以方便按区间查找
* 一般情况，根节点会被存储在内存中，其他节点存储在磁盘中

B-树的`-`并不是减的意思，而只是一个连接符，B-树即B树。B树实际上是低级版的B+树，或者说B+树是B树的改进版。B树跟B+树的不同点主要集中在这几个地方：

* B+树中的节点不存储数据，只是索引，而B树中的节点存储数据
* B树中的叶子节点并不需要链表来串联

即，**B树只是一个每个节点的子节点个数不能小于`m/2`的m叉树**。

