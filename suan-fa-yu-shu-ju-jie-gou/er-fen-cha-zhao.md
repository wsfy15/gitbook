# 二分查找

针对**有序的数据集合**，每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为0。

假设数据大小是n，每次查找后数据都会缩小为原来的一半，也就是会除以2。最坏情况下，直到查找区间被缩小为空，才停止。被查找区间的大小变化：$n,n/2,n/4,……,n/2^k,……$，这是一个等比数列。其中$n/2^k = 1$时，k的值就是总共缩小的次数。而每一次缩小操作只涉及两个数据的大小比较，所以，经过了k次区间缩小操作，时间复杂度就是$O\(k\)$。通过$n/2^k=1$，我们可以求得$k=log\_2n$，所以时间复杂度就是$O\(logn\)$。

## 简单实现

简单体现在没有重复元素。

### 非递归实现

```text
func bsearch(a []int, val int) int {
    low := 0
    high := len(a) - 1
    for low <= high {
        mid := low + ((high - low) >> 1);
        if a[mid] == val {
            return mid
        } else if a[mid] > val {
            high = mid - 1
        } else {
            low = mid + 1
        }
    } 

    return -1
}
```

### 递归实现

```text
func bsearch(a []int, val, low, high int) int {
    if low > high {
        return -1
    }
    mid := low + ((high - low) >> 1);
    if a[mid] == val {
        return mid
    } else if a[mid] > val {
        return bsearch(a, val, low, mid - 1)
    } else {
        return bsearch(a, val, mid + 1, high)
    }
}
```

## 局限性

* **依赖顺序表结构**，简单点说就是数组。二分查找算法需要按照下标随机访问元素，因此不能用链表。数组按照下标随机访问数据的时间复杂度是O\(1\)，而链表随机访问的时间复杂度是O\(n\)。所以，如果数据使用链表存储，二分查找的时间复杂就会变得很高。
* **针对有序数据**。

  如果针对的是一组静态的数据，没有频繁地插入、删除，我们可以进行一次排序，多次二分查找。这样排序的成本可被均摊，二分查找的边际成本就会比较低。

  但是，如果数据集合有频繁的插入和删除操作，要想用二分查找，要么每次插入、删除操作之后保证数据仍然有序，要么在每次二分查找之前都先进行排序。针对这种动态数据集合，无论哪种方法，维护有序的成本都是很高的。

* **数据量太小不适合二分查找。**

  如果要处理的数据量很小，完全没有必要用二分查找，顺序遍历就足够了。比如我们在一个大小为10的数组中查找一个元素，不管用二分查找还是顺序遍历，查找速度都差不多。只有数据量比较大的时候，二分查找的优势才会比较明显。

  除非数据之间的比较操作非常耗时，不管数据量大小，都推荐使用二分查找。

* **数据量太大也不适合二分查找**。

  因为二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻。

  比如，我们有1GB大小的数据，如果希望用数组来存储，那就需要1GB 的**连续**内存空间。

## 常见变体

### 查找第一个值等于给定值的元素

```text
func bsearch(a []int, val int) int {
    low := 0
    high := len(a) - 1
    for low <= high {
        mid := low + ((high - low) >> 1);
        if a[mid] == val {
            if mid == 0 || a[mid - 1] != val { // 重点
                return mid
            } else {
                high = mid - 1;
            }
        } else if a[mid] > val {
            high = mid - 1
        } else {
            low = mid + 1
        }
    } 

    return -1
}
```

### 查找最后一个值等于给定值的元素

```text
func bsearch(a []int, val int) int {
    low := 0
    high := len(a) - 1
    for low <= high {
        mid := low + ((high - low) >> 1);
        if a[mid] == val {
            if mid == len(a) - 1 || a[mid + 1] != val { // 重点
                return mid
            } else {
                low = mid + 1;
            }
        } else if a[mid] > val {
            high = mid - 1
        } else {
            low = mid + 1
        }
    } 

    return -1
}
```

### 查找第一个大于等于给定值的元素

```text
func bsearch(a []int, val int) int {
    low := 0
    high := len(a) - 1
    for low <= high {
        mid := low + ((high - low) >> 1);
        if a[mid] >= val {
            if mid == 0 || a[mid - 1] < val {
                return mid
            } else {
                high = mid - 1
            }
        } else {
            low = mid + 1
        }
    } 

    return -1
}
```

### 查找最后一个小于等于给定值的元素

```text
func bsearch(a []int, val int) int {
    low := 0
    high := len(a) - 1
    for low <= high {
        mid := low + ((high - low) >> 1);
        if a[mid] > val {
            high = mid - 1
        } else {
            if mid == len(a) - 1 || a[mid + 1] > val {
                return mid
            }
            low = mid + 1
        }
    } 

    return -1
}
```

## 应用

### 确定IPv4地址的归属地

假设地址库以下面格式存储：

```text
[202.102.133.0, 202.102.133.255] 山东东营市
[202.102.135.0, 202.102.136.255] 山东烟台
[202.102.156.34, 202.102.157.255] 山东青岛
[202.102.48.0, 202.102.48.255] 江苏宿迁
[202.102.49.15, 202.102.51.251] 江苏泰州
[202.102.56.0, 202.102.56.255] 江苏连云港
```

可以先把地址库中的IPv4地址转换为32位整数，并进行排序。然后也将待查找IP转为32位整数，进行二分查找，找到最后一个起始IP小于等于这个IP的IP区间，然后检查这个IP是否在这个IP区间内，如果在，就取出对应的归属地显示；如果不在，就返回未查找到。

### 在循环有序数组中查找

循环有序数组：例如 `[4，5，6，1，2，3]`

* 找到分界下标，分成两个有序数组。然后判断目标值在哪个有序范围内，进行二分查找
* 找到最大值下标x，所有元素下标做+x偏移（取模），对偏移后的数组做二分查找，若找到目标下标，再作-x偏移（+n -x 再取模）
* 以数组中间点为分区，将数组分成一个有序数组和一个循环有序数组。

  如果首元素小于 mid，说明前半部分是有序的，后半部分是循环有序数组； 如果首元素大于 mid，说明后半部分是有序的，前半部分是循环有序的数组；

  如果目标元素在有序数组范围中，使用二分查找； 如果目标元素在循环有序数组中，设定数组边界后，使用以上方法继续查找。

