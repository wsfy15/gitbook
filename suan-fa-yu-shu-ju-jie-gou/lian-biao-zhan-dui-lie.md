# 链表、栈、队列

## 链表

* 指针丢失和内存泄漏问题
* 边界条件处理
  * 如果链表为空时，代码是否能正常工作？
  * 如果链表只包含一个结点时，代码是否能正常工作？
  * 如果链表只包含两个结点时，代码是否能正常工作？
  * 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？
* 哨兵 以在数组中查找某个值为例，比较下面两段代码：

  ```text
  // 在数组a中，查找key，返回key所在的位置
  // 其中，n表示数组a的长度
  int find(char* a, int n, char key) {
    // 边界条件处理，如果a为空，或者n<=0，说明数组中没有数据，就不用while循环比较了
    if(a == null || n <= 0) {
      return -1;
    }

    int i = 0;
    // 这里有两个比较操作：i<n和a[i]==key.
    while (i < n) {
     if (a[i] == key) {
       return i;
     }
     ++i;
   }

   return -1;
  }
  ```

  ```text
   // a = {4, 2, 3, 5, 9, 6} n=6 key = 7
   int find(char* a, int n, char key) {
     if(a == null || n <= 0) {
       return -1;
     }

     // 这里因为要将a[n-1]的值替换成key，所以要特殊处理这个值
     if (a[n-1] == key) {
       return n-1;
     }

     // 把a[n-1]的值临时保存在变量tmp中，以便之后恢复。tmp=6。
     // 之所以这样做的目的是：希望find()代码不要改变a数组中的内容
     char tmp = a[n-1];
     // 把key的值放到a[n-1]中，此时a = {4, 2, 3, 5, 9, 7}
     a[n-1] = key;

     int i = 0;
     // while 循环比起代码一，少了i<n这个比较操作
     while (a[i] != key) {
       ++i;
     }

     // 恢复a[n-1]原来的值,此时a= {4, 2, 3, 5, 9, 6}
     a[n-1] = tmp;

     if (i == n-1) {
       // 如果i == n-1说明，在0...n-2之间都没有key，所以返回-1
       return -1;
     } else {
       // 否则，返回i，就是等于key值的元素的下标
       return i;
     }
  }
  ```

  下面这段代码将数组最后一个元素作为哨兵，减少了在循环中的边界判断，当数组很大时，节省的时间就很可观。但可读性也降低了，一般不需要如此优化。

### leetcode相关题目

[单链表反转](https://leetcode.com/problems/reverse-linked-list/) [链表中环的检测](https://leetcode.com/problems/linked-list-cycle/) [两个有序的链表合并](https://leetcode.com/problems/merge-two-sorted-lists/) [删除链表倒数第n个结点](https://leetcode.com/problems/remove-nth-node-from-end-of-list/) [求链表的中间结点](https://leetcode.com/problems/middle-of-the-linked-list/)

## 栈

通过两个栈（`S1 和 S2`）实现浏览器的前进、后退功能：

1. 比如你顺序查看了a，b，c三个页面，我们就依次把a，b，c压入栈

   `S1: a、b、c` （按栈底到栈顶的顺序显示元素）

   `S2: null`

2. 通过浏览器的后退按钮，从页面c后退到页面a之后，我们就依次把c和b从栈`S1`中弹出，并且依次放入到栈`S2`

   `S1: a` 

   `S2: c、b`

3. 此时前进一下，将b页面从S2中弹出，入栈到S1

   `S1: a、b`

   `S2: c`

4. 通过页面b又跳转到新的页面d了，页面c就无法再通过前进、后退按钮重复查看了，所以需要清空栈Y。`S1: a、b、d`

   `S2: null`

## 队列

先进先出，需要记录队头和队尾指针。

**顺序队列**：用数组实现，队尾到达数组最后一个元素时，若前面存在空闲，需要将所有元素往队头方向挪动。

**链式队列**：不存在顺序队列的这个问题

**循环队列**：用数组实现，当队尾到达数组最后一个元素时，下一个位置是数组的第一个元素（若空闲）。队头和队尾移动时需要除以数组长度取模。判断队空用`head == tail`，判断队满用`(tail + 1) % n == head`\(会浪费一个元素的空间，可以考虑用额外的变量size存储当前队列元素个数\)

**阻塞队列**：在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。

**并发队列**：线程安全的队列，最简单直接的实现方式是直接在入队、出队方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用CAS原子操作，可以实现非常高效的并发队列。

